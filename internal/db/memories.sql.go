// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: memories.sql

package db

import (
	"context"
	"database/sql"
)

const createMemory = `-- name: CreateMemory :exec
INSERT INTO memories (
    id, agent_handle, path_scope, content, category, embedding,
    source_session_id, source_message_id, created_at, updated_at,
    confidence, status
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateMemoryParams struct {
	ID              string         `json:"id"`
	AgentHandle     sql.NullString `json:"agent_handle"`
	PathScope       sql.NullString `json:"path_scope"`
	Content         string         `json:"content"`
	Category        string         `json:"category"`
	Embedding       []byte         `json:"embedding"`
	SourceSessionID sql.NullString `json:"source_session_id"`
	SourceMessageID sql.NullString `json:"source_message_id"`
	CreatedAt       int64          `json:"created_at"`
	UpdatedAt       int64          `json:"updated_at"`
	Confidence      sql.NullFloat64 `json:"confidence"`
	Status          sql.NullString `json:"status"`
}

func (q *Queries) CreateMemory(ctx context.Context, arg CreateMemoryParams) error {
	_, err := q.exec(ctx, q.createMemoryStmt, createMemory,
		arg.ID,
		arg.AgentHandle,
		arg.PathScope,
		arg.Content,
		arg.Category,
		arg.Embedding,
		arg.SourceSessionID,
		arg.SourceMessageID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Confidence,
		arg.Status,
	)
	return err
}

const getMemory = `-- name: GetMemory :one
SELECT id, agent_handle, path_scope, content, category, embedding, source_session_id, source_message_id, created_at, updated_at, confidence, last_accessed_at, access_count, supersedes_id, superseded_by_id, supersession_reason, status FROM memories WHERE id = ?
`

func (q *Queries) GetMemory(ctx context.Context, id string) (Memory, error) {
	row := q.queryRow(ctx, q.getMemoryStmt, getMemory, id)
	var i Memory
	err := row.Scan(
		&i.ID,
		&i.AgentHandle,
		&i.PathScope,
		&i.Content,
		&i.Category,
		&i.Embedding,
		&i.SourceSessionID,
		&i.SourceMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Confidence,
		&i.LastAccessedAt,
		&i.AccessCount,
		&i.SupersedesID,
		&i.SupersededByID,
		&i.SupersessionReason,
		&i.Status,
	)
	return i, err
}

const updateMemory = `-- name: UpdateMemory :exec
UPDATE memories SET
    content = ?,
    category = ?,
    embedding = ?,
    confidence = ?,
    updated_at = ?
WHERE id = ?
`

type UpdateMemoryParams struct {
	Content    string          `json:"content"`
	Category   string          `json:"category"`
	Embedding  []byte          `json:"embedding"`
	Confidence sql.NullFloat64 `json:"confidence"`
	UpdatedAt  int64           `json:"updated_at"`
	ID         string          `json:"id"`
}

func (q *Queries) UpdateMemory(ctx context.Context, arg UpdateMemoryParams) error {
	_, err := q.exec(ctx, q.updateMemoryStmt, updateMemory,
		arg.Content,
		arg.Category,
		arg.Embedding,
		arg.Confidence,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateMemoryAccess = `-- name: UpdateMemoryAccess :exec
UPDATE memories SET
    last_accessed_at = ?,
    access_count = access_count + 1
WHERE id = ?
`

type UpdateMemoryAccessParams struct {
	LastAccessedAt sql.NullInt64 `json:"last_accessed_at"`
	ID             string        `json:"id"`
}

func (q *Queries) UpdateMemoryAccess(ctx context.Context, arg UpdateMemoryAccessParams) error {
	_, err := q.exec(ctx, q.updateMemoryAccessStmt, updateMemoryAccess, arg.LastAccessedAt, arg.ID)
	return err
}

const supersedeMemory = `-- name: SupersedeMemory :exec
UPDATE memories SET
    status = 'superseded',
    superseded_by_id = ?,
    updated_at = ?
WHERE id = ?
`

type SupersedeMemoryParams struct {
	SupersededByID sql.NullString `json:"superseded_by_id"`
	UpdatedAt      int64          `json:"updated_at"`
	ID             string         `json:"id"`
}

func (q *Queries) SupersedeMemory(ctx context.Context, arg SupersedeMemoryParams) error {
	_, err := q.exec(ctx, q.supersedeMemoryStmt, supersedeMemory,
		arg.SupersededByID,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const forgetMemory = `-- name: ForgetMemory :exec
UPDATE memories SET
    status = 'forgotten',
    updated_at = ?
WHERE id = ?
`

type ForgetMemoryParams struct {
	UpdatedAt int64  `json:"updated_at"`
	ID        string `json:"id"`
}

func (q *Queries) ForgetMemory(ctx context.Context, arg ForgetMemoryParams) error {
	_, err := q.exec(ctx, q.forgetMemoryStmt, forgetMemory, arg.UpdatedAt, arg.ID)
	return err
}

const deleteMemory = `-- name: DeleteMemory :exec
DELETE FROM memories WHERE id = ?
`

func (q *Queries) DeleteMemory(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteMemoryStmt, deleteMemory, id)
	return err
}

const listMemories = `-- name: ListMemories :many
SELECT id, agent_handle, path_scope, content, category, embedding, source_session_id, source_message_id, created_at, updated_at, confidence, last_accessed_at, access_count, supersedes_id, superseded_by_id, supersession_reason, status FROM memories
WHERE status = COALESCE(?, 'active')
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListMemoriesParams struct {
	Status sql.NullString `json:"status"`
	Limit  int64          `json:"limit"`
	Offset int64          `json:"offset"`
}

func (q *Queries) ListMemories(ctx context.Context, arg ListMemoriesParams) ([]Memory, error) {
	rows, err := q.query(ctx, q.listMemoriesStmt, listMemories, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Memory{}
	for rows.Next() {
		var i Memory
		if err := rows.Scan(
			&i.ID,
			&i.AgentHandle,
			&i.PathScope,
			&i.Content,
			&i.Category,
			&i.Embedding,
			&i.SourceSessionID,
			&i.SourceMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Confidence,
			&i.LastAccessedAt,
			&i.AccessCount,
			&i.SupersedesID,
			&i.SupersededByID,
			&i.SupersessionReason,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMemoriesByAgent = `-- name: ListMemoriesByAgent :many
SELECT id, agent_handle, path_scope, content, category, embedding, source_session_id, source_message_id, created_at, updated_at, confidence, last_accessed_at, access_count, supersedes_id, superseded_by_id, supersession_reason, status FROM memories
WHERE agent_handle = ?
  AND status = COALESCE(?, 'active')
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListMemoriesByAgentParams struct {
	AgentHandle sql.NullString `json:"agent_handle"`
	Status      sql.NullString `json:"status"`
	Limit       int64          `json:"limit"`
	Offset      int64          `json:"offset"`
}

func (q *Queries) ListMemoriesByAgent(ctx context.Context, arg ListMemoriesByAgentParams) ([]Memory, error) {
	rows, err := q.query(ctx, q.listMemoriesByAgentStmt, listMemoriesByAgent,
		arg.AgentHandle,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Memory{}
	for rows.Next() {
		var i Memory
		if err := rows.Scan(
			&i.ID,
			&i.AgentHandle,
			&i.PathScope,
			&i.Content,
			&i.Category,
			&i.Embedding,
			&i.SourceSessionID,
			&i.SourceMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Confidence,
			&i.LastAccessedAt,
			&i.AccessCount,
			&i.SupersedesID,
			&i.SupersededByID,
			&i.SupersessionReason,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemoriesForSearch = `-- name: GetMemoriesForSearch :many
SELECT id, agent_handle, path_scope, content, category, embedding, confidence,
       last_accessed_at, access_count, created_at
FROM memories
WHERE status = 'active'
  AND embedding IS NOT NULL
  AND (agent_handle = ? OR agent_handle IS NULL OR ? IS NULL)
  AND (path_scope = ? OR path_scope IS NULL OR ? IS NULL)
`

type GetMemoriesForSearchParams struct {
	AgentHandle sql.NullString `json:"agent_handle"`
	PathScope   sql.NullString `json:"path_scope"`
}

type GetMemoriesForSearchRow struct {
	ID             string          `json:"id"`
	AgentHandle    sql.NullString  `json:"agent_handle"`
	PathScope      sql.NullString  `json:"path_scope"`
	Content        string          `json:"content"`
	Category       string          `json:"category"`
	Embedding      []byte          `json:"embedding"`
	Confidence     sql.NullFloat64 `json:"confidence"`
	LastAccessedAt sql.NullInt64   `json:"last_accessed_at"`
	AccessCount    sql.NullInt64   `json:"access_count"`
	CreatedAt      int64           `json:"created_at"`
}

func (q *Queries) GetMemoriesForSearch(ctx context.Context, arg GetMemoriesForSearchParams) ([]GetMemoriesForSearchRow, error) {
	rows, err := q.query(ctx, q.getMemoriesForSearchStmt, getMemoriesForSearch,
		arg.AgentHandle,
		arg.AgentHandle,
		arg.PathScope,
		arg.PathScope,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMemoriesForSearchRow{}
	for rows.Next() {
		var i GetMemoriesForSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.AgentHandle,
			&i.PathScope,
			&i.Content,
			&i.Category,
			&i.Embedding,
			&i.Confidence,
			&i.LastAccessedAt,
			&i.AccessCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countMemories = `-- name: CountMemories :one
SELECT COUNT(*) FROM memories WHERE status = COALESCE(?, 'active')
`

func (q *Queries) CountMemories(ctx context.Context, status sql.NullString) (int64, error) {
	row := q.queryRow(ctx, q.countMemoriesStmt, countMemories, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMemoriesByAgent = `-- name: CountMemoriesByAgent :one
SELECT COUNT(*) FROM memories 
WHERE agent_handle = ?
  AND status = COALESCE(?, 'active')
`

type CountMemoriesByAgentParams struct {
	AgentHandle sql.NullString `json:"agent_handle"`
	Status      sql.NullString `json:"status"`
}

func (q *Queries) CountMemoriesByAgent(ctx context.Context, arg CountMemoriesByAgentParams) (int64, error) {
	row := q.queryRow(ctx, q.countMemoriesByAgentStmt, countMemoriesByAgent, arg.AgentHandle, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const clearMemoriesByAgent = `-- name: ClearMemoriesByAgent :exec
UPDATE memories SET
    status = 'forgotten',
    updated_at = ?
WHERE agent_handle = ?
`

type ClearMemoriesByAgentParams struct {
	UpdatedAt   int64          `json:"updated_at"`
	AgentHandle sql.NullString `json:"agent_handle"`
}

func (q *Queries) ClearMemoriesByAgent(ctx context.Context, arg ClearMemoriesByAgentParams) error {
	_, err := q.exec(ctx, q.clearMemoriesByAgentStmt, clearMemoriesByAgent, arg.UpdatedAt, arg.AgentHandle)
	return err
}

const clearAllMemories = `-- name: ClearAllMemories :exec
UPDATE memories SET
    status = 'forgotten',
    updated_at = ?
`

func (q *Queries) ClearAllMemories(ctx context.Context, updatedAt int64) error {
	_, err := q.exec(ctx, q.clearAllMemoriesStmt, clearAllMemories, updatedAt)
	return err
}
