// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package db

import (
	"context"
	"database/sql"
)

const countSessions = `-- name: CountSessions :one
SELECT COUNT(*) FROM sessions
`

func (q *Queries) CountSessions(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countSessionsStmt, countSessions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSessionsByAgent = `-- name: CountSessionsByAgent :one
SELECT COUNT(*) FROM sessions WHERE agent_handle = ?1
`

func (q *Queries) CountSessionsByAgent(ctx context.Context, agentHandle string) (int64, error) {
	row := q.queryRow(ctx, q.countSessionsByAgentStmt, countSessionsByAgent, agentHandle)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSessionsBySource = `-- name: CountSessionsBySource :one
SELECT COUNT(*) FROM sessions WHERE source = ?1
`

func (q *Queries) CountSessionsBySource(ctx context.Context, source string) (int64, error) {
	row := q.queryRow(ctx, q.countSessionsBySourceStmt, countSessionsBySource, source)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
    id,
    agent_handle,
    title,
    input_schema,
    output_schema,
    structured_input,
    structured_output,
    chain_depth,
    chain_source,
    source,
    message_count,
    created_at,
    updated_at,
    finished_at
) VALUES (
    ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, 0, strftime('%s', 'now'), strftime('%s', 'now'), NULL
) RETURNING id, agent_handle, title, input_schema, output_schema, structured_input, structured_output, chain_depth, chain_source, message_count, created_at, updated_at, finished_at, "plan", source
`

type CreateSessionParams struct {
	ID               string         `json:"id"`
	AgentHandle      string         `json:"agent_handle"`
	Title            string         `json:"title"`
	InputSchema      sql.NullString `json:"input_schema"`
	OutputSchema     sql.NullString `json:"output_schema"`
	StructuredInput  sql.NullString `json:"structured_input"`
	StructuredOutput sql.NullString `json:"structured_output"`
	ChainDepth       int64          `json:"chain_depth"`
	ChainSource      sql.NullString `json:"chain_source"`
	Source           string         `json:"source"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.queryRow(ctx, q.createSessionStmt, createSession,
		arg.ID,
		arg.AgentHandle,
		arg.Title,
		arg.InputSchema,
		arg.OutputSchema,
		arg.StructuredInput,
		arg.StructuredOutput,
		arg.ChainDepth,
		arg.ChainSource,
		arg.Source,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AgentHandle,
		&i.Title,
		&i.InputSchema,
		&i.OutputSchema,
		&i.StructuredInput,
		&i.StructuredOutput,
		&i.ChainDepth,
		&i.ChainSource,
		&i.MessageCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FinishedAt,
		&i.Plan,
		&i.Source,
	)
	return i, err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE id = ?1
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteSessionStmt, deleteSession, id)
	return err
}

const getSession = `-- name: GetSession :one
SELECT id, agent_handle, title, input_schema, output_schema, structured_input, structured_output, chain_depth, chain_source, message_count, created_at, updated_at, finished_at, "plan", source FROM sessions WHERE id = ?1 LIMIT 1
`

func (q *Queries) GetSession(ctx context.Context, id string) (Session, error) {
	row := q.queryRow(ctx, q.getSessionStmt, getSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AgentHandle,
		&i.Title,
		&i.InputSchema,
		&i.OutputSchema,
		&i.StructuredInput,
		&i.StructuredOutput,
		&i.ChainDepth,
		&i.ChainSource,
		&i.MessageCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FinishedAt,
		&i.Plan,
		&i.Source,
	)
	return i, err
}

const getSessionByPrefix = `-- name: GetSessionByPrefix :many
SELECT id, agent_handle, title, input_schema, output_schema, structured_input, structured_output, chain_depth, chain_source, message_count, created_at, updated_at, finished_at, "plan", source FROM sessions WHERE id LIKE ?1 || '%' ORDER BY updated_at DESC LIMIT 10
`

func (q *Queries) GetSessionByPrefix(ctx context.Context, prefix sql.NullString) ([]Session, error) {
	rows, err := q.query(ctx, q.getSessionByPrefixStmt, getSessionByPrefix, prefix)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.AgentHandle,
			&i.Title,
			&i.InputSchema,
			&i.OutputSchema,
			&i.StructuredInput,
			&i.StructuredOutput,
			&i.ChainDepth,
			&i.ChainSource,
			&i.MessageCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FinishedAt,
			&i.Plan,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessions = `-- name: ListSessions :many
SELECT id, agent_handle, title, input_schema, output_schema, structured_input, structured_output, chain_depth, chain_source, message_count, created_at, updated_at, finished_at, "plan", source FROM sessions ORDER BY updated_at DESC LIMIT ?1
`

func (q *Queries) ListSessions(ctx context.Context, limit int64) ([]Session, error) {
	rows, err := q.query(ctx, q.listSessionsStmt, listSessions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.AgentHandle,
			&i.Title,
			&i.InputSchema,
			&i.OutputSchema,
			&i.StructuredInput,
			&i.StructuredOutput,
			&i.ChainDepth,
			&i.ChainSource,
			&i.MessageCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FinishedAt,
			&i.Plan,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsByAgent = `-- name: ListSessionsByAgent :many
SELECT id, agent_handle, title, input_schema, output_schema, structured_input, structured_output, chain_depth, chain_source, message_count, created_at, updated_at, finished_at, "plan", source FROM sessions WHERE agent_handle = ?1 ORDER BY updated_at DESC LIMIT ?2
`

type ListSessionsByAgentParams struct {
	AgentHandle string `json:"agent_handle"`
	Limit       int64  `json:"limit"`
}

func (q *Queries) ListSessionsByAgent(ctx context.Context, arg ListSessionsByAgentParams) ([]Session, error) {
	rows, err := q.query(ctx, q.listSessionsByAgentStmt, listSessionsByAgent, arg.AgentHandle, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.AgentHandle,
			&i.Title,
			&i.InputSchema,
			&i.OutputSchema,
			&i.StructuredInput,
			&i.StructuredOutput,
			&i.ChainDepth,
			&i.ChainSource,
			&i.MessageCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FinishedAt,
			&i.Plan,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsBySource = `-- name: ListSessionsBySource :many
SELECT id, agent_handle, title, input_schema, output_schema, structured_input, structured_output, chain_depth, chain_source, message_count, created_at, updated_at, finished_at, "plan", source FROM sessions WHERE source = ?1 ORDER BY updated_at DESC LIMIT ?2
`

type ListSessionsBySourceParams struct {
	Source string `json:"source"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) ListSessionsBySource(ctx context.Context, arg ListSessionsBySourceParams) ([]Session, error) {
	rows, err := q.query(ctx, q.listSessionsBySourceStmt, listSessionsBySource, arg.Source, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.AgentHandle,
			&i.Title,
			&i.InputSchema,
			&i.OutputSchema,
			&i.StructuredInput,
			&i.StructuredOutput,
			&i.ChainDepth,
			&i.ChainSource,
			&i.MessageCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FinishedAt,
			&i.Plan,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSessionsByTitle = `-- name: SearchSessionsByTitle :many
SELECT id, agent_handle, title, input_schema, output_schema, structured_input, structured_output, chain_depth, chain_source, message_count, created_at, updated_at, finished_at, "plan", source FROM sessions WHERE title LIKE '%' || ?1 || '%' ORDER BY updated_at DESC LIMIT ?2
`

type SearchSessionsByTitleParams struct {
	Query sql.NullString `json:"query"`
	Limit int64          `json:"limit"`
}

func (q *Queries) SearchSessionsByTitle(ctx context.Context, arg SearchSessionsByTitleParams) ([]Session, error) {
	rows, err := q.query(ctx, q.searchSessionsByTitleStmt, searchSessionsByTitle, arg.Query, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.AgentHandle,
			&i.Title,
			&i.InputSchema,
			&i.OutputSchema,
			&i.StructuredInput,
			&i.StructuredOutput,
			&i.ChainDepth,
			&i.ChainSource,
			&i.MessageCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FinishedAt,
			&i.Plan,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSession = `-- name: UpdateSession :one
UPDATE sessions SET
    title = ?1,
    structured_output = ?2,
    finished_at = ?3,
    updated_at = strftime('%s', 'now')
WHERE id = ?4
RETURNING id, agent_handle, title, input_schema, output_schema, structured_input, structured_output, chain_depth, chain_source, message_count, created_at, updated_at, finished_at, "plan", source
`

type UpdateSessionParams struct {
	Title            string         `json:"title"`
	StructuredOutput sql.NullString `json:"structured_output"`
	FinishedAt       sql.NullInt64  `json:"finished_at"`
	ID               string         `json:"id"`
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) (Session, error) {
	row := q.queryRow(ctx, q.updateSessionStmt, updateSession,
		arg.Title,
		arg.StructuredOutput,
		arg.FinishedAt,
		arg.ID,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AgentHandle,
		&i.Title,
		&i.InputSchema,
		&i.OutputSchema,
		&i.StructuredInput,
		&i.StructuredOutput,
		&i.ChainDepth,
		&i.ChainSource,
		&i.MessageCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FinishedAt,
		&i.Plan,
		&i.Source,
	)
	return i, err
}

const updateSessionPlan = `-- name: UpdateSessionPlan :one
UPDATE sessions SET
    plan = ?1,
    updated_at = strftime('%s', 'now')
WHERE id = ?2
RETURNING id, agent_handle, title, input_schema, output_schema, structured_input, structured_output, chain_depth, chain_source, message_count, created_at, updated_at, finished_at, "plan", source
`

type UpdateSessionPlanParams struct {
	Plan sql.NullString `json:"plan"`
	ID   string         `json:"id"`
}

func (q *Queries) UpdateSessionPlan(ctx context.Context, arg UpdateSessionPlanParams) (Session, error) {
	row := q.queryRow(ctx, q.updateSessionPlanStmt, updateSessionPlan, arg.Plan, arg.ID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AgentHandle,
		&i.Title,
		&i.InputSchema,
		&i.OutputSchema,
		&i.StructuredInput,
		&i.StructuredOutput,
		&i.ChainDepth,
		&i.ChainSource,
		&i.MessageCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FinishedAt,
		&i.Plan,
		&i.Source,
	)
	return i, err
}

const updateSessionTitle = `-- name: UpdateSessionTitle :exec
UPDATE sessions SET
    title = ?1,
    updated_at = strftime('%s', 'now')
WHERE id = ?2
`

type UpdateSessionTitleParams struct {
	Title string `json:"title"`
	ID    string `json:"id"`
}

func (q *Queries) UpdateSessionTitle(ctx context.Context, arg UpdateSessionTitleParams) error {
	_, err := q.exec(ctx, q.updateSessionTitleStmt, updateSessionTitle, arg.Title, arg.ID)
	return err
}
